---
{"dg-publish":true,"permalink":"/docs/csharp/exceptions-handling/","tags":["exceptions","try-catch","finally"]}
---

# Exceptions and Exception Handling in C#

## Overview

**Exceptions** are a structured, uniform, and type-safe mechanism for managing runtime errors in C# applications. They allow programs to handle unexpected situations gracefully instead of crashing.

---

## What Are Exceptions?

Exceptions are **objects** that represent errors occurring during program execution. They are:

- Instances of classes derived from `System.Exception`
- Generated by the .NET runtime or application code
- Contain information about the error type and details

```csharp
// When this runs with x = 0, an exception is thrown
int result = 10 / x;  // DivideByZeroException if x is 0
```

---

## Common Scenarios Requiring Exception Handling

| Category | Examples |
|----------|----------|
| **User Input** | Wrong format, out-of-range values, null input |
| **Calculations** | Division by zero, overflow, invalid type casts |
| **File I/O** | Missing files, permission denied, file in use |
| **Database** | Lost connection, SQL errors, constraint violations |
| **Network** | Connection timeout, server unavailable, DNS failure |
| **External APIs** | Web service errors, invalid responses, rate limits |

---

## Exception Handling Keywords

C# provides three keywords for exception handling:

| Keyword | Purpose |
|---------|---------|
| `try` | Contains code that might throw an exception |
| `catch` | Handles the exception when it occurs |
| `finally` | Cleanup code that always runs |

---

## Basic Syntax

```csharp
try
{
    // Code that may throw an exception
}
catch
{
    // Code to handle the exception
}
finally
{
    // Cleanup code (always executes)
}
```

---

## Try-Catch Block

The most common pattern for handling exceptions:

```csharp
try
{
    int[] numbers = { 1, 2, 3 };
    Console.WriteLine(numbers[10]);  // This will throw an exception
}
catch
{
    Console.WriteLine("An error occurred!");
}
```

**Output:**
```
An error occurred!
```

### Catching Specific Exception Types

```csharp
try
{
    int[] numbers = { 1, 2, 3 };
    Console.WriteLine(numbers[10]);
}
catch (IndexOutOfRangeException)
{
    Console.WriteLine("Index was outside the bounds of the array.");
}
```

### Accessing Exception Information

```csharp
try
{
    int result = 10 / 0;
}
catch (DivideByZeroException ex)
{
    Console.WriteLine($"Error: {ex.Message}");
    Console.WriteLine($"Source: {ex.Source}");
    Console.WriteLine($"Stack Trace: {ex.StackTrace}");
}
```

**Output:**
```
Error: Attempted to divide by zero.
Source: YourApplication
Stack Trace:    at Program.Main() in Program.cs:line 5
```

---

## Multiple Catch Blocks

Handle different exception types differently:

```csharp
try
{
    // Code that might throw various exceptions
    string input = Console.ReadLine();
    int number = int.Parse(input);
    int result = 100 / number;
    Console.WriteLine($"Result: {result}");
}
catch (FormatException)
{
    Console.WriteLine("Please enter a valid number.");
}
catch (DivideByZeroException)
{
    Console.WriteLine("Cannot divide by zero.");
}
catch (Exception ex)
{
    Console.WriteLine($"Unexpected error: {ex.Message}");
}
```

### Order Matters

Catch blocks are evaluated **top to bottom**. More specific exceptions must come before general ones:

```csharp
// ✅ Correct order - specific to general
try { }
catch (FileNotFoundException) { }    // Specific
catch (IOException) { }              // More general
catch (Exception) { }                // Most general

// ❌ Wrong order - compiler error
try { }
catch (Exception) { }                // Too general first
catch (FileNotFoundException) { }    // Never reached!
```

---

## The Finally Block

The `finally` block **always executes**, whether an exception occurs or not. Use it for cleanup operations.

```csharp
StreamReader reader = null;

try
{
    reader = new StreamReader("file.txt");
    string content = reader.ReadToEnd();
    Console.WriteLine(content);
}
catch (FileNotFoundException)
{
    Console.WriteLine("File not found.");
}
finally
{
    // Always runs - close the file
    if (reader != null)
    {
        reader.Close();
        Console.WriteLine("File closed.");
    }
}
```

### Finally Execution Scenarios

| Scenario | Finally Runs? |
|----------|---------------|
| No exception occurs | ✅ Yes |
| Exception is caught | ✅ Yes |
| Exception is not caught | ✅ Yes (before app terminates) |
| Return statement in try | ✅ Yes |

```csharp
int GetNumber()
{
    try
    {
        return 42;
    }
    finally
    {
        Console.WriteLine("Finally runs even with return!");
    }
}
// Output: "Finally runs even with return!"
// Returns: 42
```

---

## Try-Finally (Without Catch)

Ensures cleanup without handling the exception:

```csharp
void ProcessFile()
{
    FileStream file = File.Open("data.txt", FileMode.Open);

    try
    {
        // Process the file
        // If an exception occurs, it will propagate up
    }
    finally
    {
        // But the file will always be closed
        file.Close();
    }
}
```

---

## The Call Stack

The **call stack** tracks the sequence of method calls during execution.

```csharp
void Main()
{
    MethodA();
}

void MethodA()
{
    MethodB();
}

void MethodB()
{
    MethodC();
}

void MethodC()
{
    throw new Exception("Error!");  // Exception occurs here
}
```

### Call Stack Visualization

```
┌─────────────┐
│  MethodC()  │  ← Exception thrown here
├─────────────┤
│  MethodB()  │
├─────────────┤
│  MethodA()  │
├─────────────┤
│   Main()    │
└─────────────┘
```

### Call Stack Unwinding

When an exception is thrown, the runtime searches **up the call stack** for a matching `catch` block:

1. Check current method for `try-catch`
2. If not found, move to the calling method
3. Continue until a `catch` is found or the stack is empty
4. Execute all `finally` blocks along the way
5. If no `catch` is found, the application terminates

```csharp
void Main()
{
    try
    {
        MethodA();
    }
    catch (Exception ex)
    {
        // Exception from MethodC is caught here
        Console.WriteLine($"Caught: {ex.Message}");
    }
}

void MethodA()
{
    MethodB();  // No try-catch, exception propagates up
}

void MethodB()
{
    MethodC();  // No try-catch, exception propagates up
}

void MethodC()
{
    throw new Exception("Error in MethodC!");
}
```

---

## Common Exception Types

| Exception | Cause |
|-----------|-------|
| `Exception` | Base class for all exceptions |
| `ArgumentException` | Invalid argument passed to method |
| `ArgumentNullException` | Null passed when not allowed |
| `ArgumentOutOfRangeException` | Argument outside valid range |
| `DivideByZeroException` | Division by zero |
| `IndexOutOfRangeException` | Array index out of bounds |
| `InvalidCastException` | Invalid type conversion |
| `InvalidOperationException` | Operation not valid for current state |
| `NullReferenceException` | Accessing member on null object |
| `FileNotFoundException` | File does not exist |
| `IOException` | General I/O error |
| `FormatException` | String format is invalid |
| `OverflowException` | Arithmetic overflow |
| `TimeoutException` | Operation timed out |

---

## Exception Properties

Every exception object has useful properties:

| Property | Description |
|----------|-------------|
| `Message` | Human-readable error description |
| `StackTrace` | String showing the call stack |
| `Source` | Name of the application/object causing error |
| `InnerException` | The exception that caused this exception |
| `Data` | Dictionary of additional information |
| `HelpLink` | URL to help documentation |

```csharp
try
{
    // Code that throws
}
catch (Exception ex)
{
    Console.WriteLine($"Message: {ex.Message}");
    Console.WriteLine($"Type: {ex.GetType().Name}");
    Console.WriteLine($"Stack Trace:\n{ex.StackTrace}");

    if (ex.InnerException != null)
    {
        Console.WriteLine($"Inner: {ex.InnerException.Message}");
    }
}
```

---

## Practical Examples

### Safe User Input

```csharp
int GetValidNumber()
{
    while (true)
    {
        Console.Write("Enter a number: ");
        string input = Console.ReadLine();

        try
        {
            return int.Parse(input);
        }
        catch (FormatException)
        {
            Console.WriteLine("Invalid format. Please enter a valid number.");
        }
    }
}
```

### Safe File Reading

```csharp
string ReadFileContent(string path)
{
    try
    {
        return File.ReadAllText(path);
    }
    catch (FileNotFoundException)
    {
        Console.WriteLine($"File not found: {path}");
        return string.Empty;
    }
    catch (UnauthorizedAccessException)
    {
        Console.WriteLine($"Access denied: {path}");
        return string.Empty;
    }
    catch (IOException ex)
    {
        Console.WriteLine($"I/O error: {ex.Message}");
        return string.Empty;
    }
}
```

### Safe Division

```csharp
double SafeDivide(double dividend, double divisor)
{
    try
    {
        if (divisor == 0)
        {
            throw new DivideByZeroException("Cannot divide by zero");
        }
        return dividend / divisor;
    }
    catch (DivideByZeroException ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
        return 0;
    }
}
```

---

## Exception Handling Patterns Summary

### Pattern 1: Try-Catch

Handle exceptions and continue execution:

```csharp
try
{
    // Risky code
}
catch (SpecificException ex)
{
    // Handle the exception
}
```

### Pattern 2: Try-Finally

Ensure cleanup without handling:

```csharp
try
{
    // Code using resources
}
finally
{
    // Always clean up
}
```

### Pattern 3: Try-Catch-Finally

Handle exceptions and ensure cleanup:

```csharp
try
{
    // Risky code using resources
}
catch (Exception ex)
{
    // Handle exception
}
finally
{
    // Clean up resources
}
```

---

## Execution Flow Diagram

```
try block begins
       │
       ▼
┌──────────────────┐
│  Execute code    │
│  in try block    │
└────────┬─────────┘
         │
    Exception?
    ╱        ╲
  Yes         No
   │           │
   ▼           │
┌──────────┐   │
│  Match   │   │
│  catch?  │   │
└────┬─────┘   │
     │         │
   Yes         │
     │         │
     ▼         │
┌──────────┐   │
│ Execute  │   │
│  catch   │   │
└────┬─────┘   │
     │         │
     └────┬────┘
          │
          ▼
   ┌──────────────┐
   │   Execute    │
   │   finally    │
   └──────────────┘
          │
          ▼
     Continue...
```

---

## Throwing Exceptions

The `throw` keyword is used to explicitly raise an exception in your code.

### Basic Throw Syntax

```csharp
throw new ExceptionType("Error message");
```

### Creating and Throwing

```csharp
// Create and throw in one line
throw new ArgumentException("Invalid argument provided.");

// Or create first, then throw
ArgumentException ex = new ArgumentException("Value cannot be negative.");
throw ex;
```

---

## When to Throw Exceptions

Methods should throw exceptions when they **cannot complete their intended purpose**:

```csharp
void ProcessOrder(int quantity)
{
    if (quantity <= 0)
    {
        throw new ArgumentException("Quantity must be greater than zero.");
    }

    if (quantity > 1000)
    {
        throw new ArgumentOutOfRangeException(nameof(quantity),
            "Quantity cannot exceed 1000.");
    }

    // Process the order...
}
```

### Validating Input Parameters

```csharp
string FormatName(string firstName, string lastName)
{
    if (string.IsNullOrEmpty(firstName))
    {
        throw new ArgumentNullException(nameof(firstName),
            "First name cannot be null or empty.");
    }

    if (string.IsNullOrEmpty(lastName))
    {
        throw new ArgumentNullException(nameof(lastName),
            "Last name cannot be null or empty.");
    }

    return $"{lastName}, {firstName}";
}
```

---

## Choosing the Right Exception Type

Use the most **specific exception type** that matches the error:

| Situation | Exception Type |
|-----------|---------------|
| Null argument passed | `ArgumentNullException` |
| Invalid argument value | `ArgumentException` |
| Argument outside valid range | `ArgumentOutOfRangeException` |
| Invalid operation for current state | `InvalidOperationException` |
| Feature not supported | `NotSupportedException` |
| File/IO operation fails | `IOException` |
| Invalid string format | `FormatException` |

### Example: Choosing Appropriate Exceptions

```csharp
void SetAge(int age)
{
    if (age < 0)
    {
        throw new ArgumentOutOfRangeException(nameof(age),
            "Age cannot be negative.");
    }

    if (age > 150)
    {
        throw new ArgumentOutOfRangeException(nameof(age),
            "Age cannot exceed 150.");
    }

    this.Age = age;
}

void Connect()
{
    if (IsConnected)
    {
        throw new InvalidOperationException(
            "Cannot connect: Already connected.");
    }

    // Connect...
}
```

---

## Customizing Exception Messages

Provide **clear, helpful messages** that describe the problem:

```csharp
// ❌ Bad - vague message
throw new ArgumentException("Invalid input");

// ✅ Good - specific and helpful
throw new ArgumentException(
    "The 'email' parameter must be a valid email address format. " +
    $"Received: '{email}'");
```

### Exception Message Best Practices

| Do | Don't |
|----|-------|
| Describe what went wrong | Use vague messages like "Error" |
| Explain expected vs actual | Include sensitive data (passwords, etc.) |
| Suggest how to fix it | Use technical jargon users won't understand |
| Include relevant values | Reveal internal implementation details |

---

## Re-throwing Exceptions

### Re-throw Without Losing Stack Trace

Use `throw;` (without an exception) to preserve the original stack trace:

```csharp
try
{
    ProcessData();
}
catch (Exception ex)
{
    // Log the error
    Console.WriteLine($"Error: {ex.Message}");

    // Re-throw the original exception
    throw;  // Preserves stack trace
}
```

### Wrong Way to Re-throw

```csharp
catch (Exception ex)
{
    // ❌ This resets the stack trace!
    throw ex;  // Don't do this
}
```

### Wrap in a New Exception

Include the original exception as `InnerException`:

```csharp
try
{
    ProcessData();
}
catch (Exception ex)
{
    // Wrap with additional context
    throw new ApplicationException(
        "Failed to process data in the reporting module.",
        ex);  // Original exception preserved as InnerException
}
```

---

## Throw Expressions (C# 7.0+)

Use `throw` as an expression in certain contexts:

### Null-Coalescing

```csharp
string name = inputName ?? throw new ArgumentNullException(nameof(inputName));
```

### Conditional Expression

```csharp
int result = value >= 0
    ? value
    : throw new ArgumentException("Value must be non-negative.");
```

### Expression-Bodied Members

```csharp
public string Name
{
    get => _name;
    set => _name = value ?? throw new ArgumentNullException(nameof(value));
}
```

---

## Complete Example: Input Validation

```csharp
class BankAccount
{
    private decimal _balance;
    private string _accountHolder;

    public BankAccount(string accountHolder, decimal initialBalance)
    {
        // Validate account holder
        if (string.IsNullOrWhiteSpace(accountHolder))
        {
            throw new ArgumentNullException(nameof(accountHolder),
                "Account holder name is required.");
        }

        // Validate initial balance
        if (initialBalance < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(initialBalance),
                "Initial balance cannot be negative.");
        }

        _accountHolder = accountHolder;
        _balance = initialBalance;
    }

    public void Deposit(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentException(
                "Deposit amount must be positive.", nameof(amount));
        }

        _balance += amount;
    }

    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentException(
                "Withdrawal amount must be positive.", nameof(amount));
        }

        if (amount > _balance)
        {
            throw new InvalidOperationException(
                $"Insufficient funds. Balance: {_balance:C}, Requested: {amount:C}");
        }

        _balance -= amount;
    }

    public decimal GetBalance() => _balance;
}

// Usage with exception handling
try
{
    var account = new BankAccount("John Doe", 100);
    account.Deposit(50);
    account.Withdraw(200);  // This will throw
}
catch (InvalidOperationException ex)
{
    Console.WriteLine($"Transaction failed: {ex.Message}");
}
catch (ArgumentException ex)
{
    Console.WriteLine($"Invalid input: {ex.Message}");
}
```

---

## Things to Avoid When Throwing

| Don't | Why |
|-------|-----|
| Throw `System.Exception` directly | Too generic, use specific types |
| Throw `NullReferenceException` | Let the runtime throw this |
| Throw `IndexOutOfRangeException` | Let the runtime throw this |
| Use exceptions for flow control | Use if/else instead |
| Return exceptions as return values | Always use `throw` |
| Include sensitive data in messages | Security risk |

```csharp
// ❌ Bad - using exceptions for flow control
try
{
    int index = list.IndexOf(item);
    if (index == -1) throw new Exception("Not found");
}
catch { /* handle not found */ }

// ✅ Good - use normal flow control
int index = list.IndexOf(item);
if (index == -1)
{
    // Handle not found
}
```

---

## Key Takeaways

### Handling Exceptions
1. **Exceptions** are objects representing runtime errors, derived from `System.Exception`
2. Use `try` to wrap code that might throw exceptions
3. Use `catch` to handle specific exception types (order matters: specific to general)
4. Use `finally` for cleanup code that must always run
5. The **call stack** tracks method calls; exceptions "unwind" up the stack
6. `finally` runs even when `return` is used in `try` or `catch`

### Throwing Exceptions
7. Use `throw new ExceptionType("message")` to raise exceptions
8. Choose the **most specific** exception type for the situation
9. Provide **clear, helpful** error messages without sensitive data
10. Use `throw;` (not `throw ex;`) to re-throw and preserve stack trace
11. Throw exceptions when a method **cannot complete its purpose**
12. **Don't** use exceptions for normal program flow control

---

## Related Topics

- [[docs/csharp/CSharp_Methods_Syntax\|Methods Syntax]]
- [[docs/csharp/CSharp_Method_Parameters\|Method Parameters]]
- [[docs/csharp/CodeBlocksVariableScope\|Code Blocks and Variable Scope]]
- [[docs/csharp/CSharp_Learning\|C# Learning Guide]]
- Custom Exception Classes
- Using Statement (Resource Management)
- Debugging and Diagnostics

---

## Source

- [Microsoft Learn: Examine Exceptions and Exception Handling](https://learn.microsoft.com/en-us/training/modules/implement-exception-handling-c-sharp/2-examine-exceptions-exception-handling-process)
- [Microsoft Learn: Create and Throw Exceptions](https://learn.microsoft.com/en-us/training/modules/create-throw-exceptions-c-sharp/2-examine-create-exception-c-sharp)

---

#csharp #programming #exceptions #error-handling #try-catch #throw #fundamentals
